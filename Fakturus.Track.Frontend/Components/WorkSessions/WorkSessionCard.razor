@using Fakturus.Track.Frontend.Models

<div class="card @(IsHistory ? "opacity-90" : "border-2 border-primary-500")">
    <div class="space-y-4">
        <div class="flex justify-between items-start">
            <div>
                <h3 class="text-lg font-semibold text-gray-900">
                    @WorkSession.Date.ToString("dd.MM.yyyy")
                </h3>
                @if (!IsHistory && WorkSession.StopTime == null)
                {
                    <span class="inline-block mt-1 px-2 py-1 text-xs font-medium bg-green-100 text-green-800 rounded">
                        Active
                    </span>
                }
            </div>
            @if (WorkSession.IsPendingSync && !WorkSession.IsSynced)
            {
                <span class="inline-block px-2 py-1 text-xs font-medium bg-yellow-100 text-yellow-800 rounded">
                    Pending Sync
                </span>
            }
        </div>

        <div class="space-y-4">
            <div>
                <label class="block text-sm font-medium text-gray-700 mb-1">Start Time</label>
                <div class="flex items-center gap-2">
                    <input type="datetime-local" 
                           value="@(WorkSession.StartTime != default ? FormatDateTimeLocal(WorkSession.StartTime) : "")" 
                           @onchange="@((ChangeEventArgs e) => HandleTimeChange(e, "start"))"
                           class="flex-1 px-3 py-2 border border-gray-300 rounded-lg focus:ring-2 focus:ring-primary-500 focus:border-transparent" />
                    <button @onclick="() => OnStart.InvokeAsync(WorkSession)" 
                            class="btn-secondary text-sm px-4 py-2 whitespace-nowrap">
                        Set Now
                    </button>
                </div>
            </div>

            <div>
                <label class="block text-sm font-medium text-gray-700 mb-1">Stop Time</label>
                <div class="flex items-center gap-2">
                    <input type="datetime-local" 
                           value="@(WorkSession.StopTime.HasValue ? FormatDateTimeLocal(WorkSession.StopTime.Value) : "")" 
                           @onchange="@((ChangeEventArgs e) => HandleTimeChange(e, "stop"))"
                           class="flex-1 px-3 py-2 border border-gray-300 rounded-lg focus:ring-2 focus:ring-primary-500 focus:border-transparent" />
                    <button @onclick="() => OnStop.InvokeAsync(WorkSession)" 
                            class="btn-secondary text-sm px-4 py-2 whitespace-nowrap">
                        Set Now
                    </button>
                </div>
            </div>
        </div>

        @if (WorkSession.StartTime != default && WorkSession.StopTime.HasValue && WorkSession.StartTime != DateTime.MinValue)
        {
            <div class="pt-2 border-t border-gray-200">
                <p class="text-sm text-gray-600">
                    Duration: <span class="font-semibold">@CalculateDuration(WorkSession.StartTime, WorkSession.StopTime.Value)</span>
                </p>
            </div>
        }

        <div class="flex gap-2 pt-2">
            @if (!IsHistory)
            {
                <button @onclick="() => OnNew.InvokeAsync()" 
                        class="flex-1 btn-outline text-sm">
                    New Session
                </button>
            }
            <button @onclick="() => OnEdit.InvokeAsync(WorkSession)" 
                    class="flex-1 btn-outline text-sm">
                Edit
            </button>
            <button @onclick="() => OnDelete.InvokeAsync(WorkSession)" 
                    class="px-4 py-2 text-sm font-semibold text-red-600 hover:text-red-700 border-2 border-red-500 hover:bg-red-50 rounded-lg transition-all duration-200">
                Delete
            </button>
        </div>
    </div>
</div>

@code {
    [Parameter] public WorkSessionModel WorkSession { get; set; } = null!;
    [Parameter] public EventCallback<WorkSessionModel> OnStart { get; set; }
    [Parameter] public EventCallback<WorkSessionModel> OnStop { get; set; }
    [Parameter] public EventCallback<WorkSessionModel> OnEdit { get; set; }
    [Parameter] public EventCallback<WorkSessionModel> OnSave { get; set; }
    [Parameter] public EventCallback<WorkSessionModel> OnDelete { get; set; }
    [Parameter] public EventCallback OnNew { get; set; }
    [Parameter] public bool IsHistory { get; set; } = false;

    private string FormatDateTimeLocal(DateTime dateTime)
    {
        // Handle default/empty DateTime
        if (dateTime == default || dateTime == DateTime.MinValue)
            return "";
        
        // Convert UTC to local time for display
        var localTime = dateTime.ToLocalTime();
        return localTime.ToString("yyyy-MM-ddTHH:mm");
    }

    private async Task HandleTimeChange(ChangeEventArgs e, string type)
    {
        if (string.IsNullOrEmpty(e.Value?.ToString()))
            return;

        if (DateTime.TryParse(e.Value.ToString(), out var parsedTime))
        {
            var utcTime = parsedTime.ToUniversalTime();
            
            if (type == "start")
            {
                WorkSession.StartTime = utcTime;
                WorkSession.Date = DateOnly.FromDateTime(parsedTime);
            }
            else if (type == "stop")
            {
                WorkSession.StopTime = utcTime;
            }

            WorkSession.IsPendingSync = true;
            await OnSave.InvokeAsync(WorkSession);
        }
    }

    private string CalculateDuration(DateTime start, DateTime stop)
    {
        var duration = stop - start;
        var hours = (int)duration.TotalHours;
        var minutes = duration.Minutes;
        return $"{hours}h {minutes}m";
    }
}

